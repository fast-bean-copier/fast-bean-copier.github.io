<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>常见问题 - Fast Bean Copier</title>
    <link rel="icon" type="image/png" href="../favicon.png">
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="logo-container">
                <img src="../logo.png" alt="Fast Bean Copier Logo" class="logo">
                <h1>🚀 Fast Bean Copier</h1>
            </div>
            <p>高性能的 Java Bean 拷贝工具</p>
            <div class="version-badge">版本 1.2.1</div>
        </div>
    </header>
    
    <nav>
        <ul>
            <li><a href="index.html">首页</a></li>
            <li><a href="getting-started.html">快速入门</a></li>
            <li><a href="reference.html">参考文档</a></li>
            <li><a href="api.html">API 文档</a></li>
            <li><a href="faq.html" class="active">常见问题</a></li>
            <li><a href="summary.html">项目总结</a></li>
            <li><a href="changelog.html">更新日志</a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="content">
            <h1>Fast Bean Copier 常见问题解答</h1>
            
            <h2>许可证</h2>
            <p>本项目采用 Apache License 2.0 许可证。</p>
            
            <h2>基本问题</h2>
            
            <h3>Q: v1.2 有哪些新增/改进？</h3>
            <p><strong>A</strong>: 主要新增多字段映射（多对一、一对多）、6 种内置 TypeConverter 类型转换器（NumberFormatter、NumberParser、DateFormatter、DateParser、EnumStringConverter、JsonConverter）、表达式映射、依赖注入支持（Spring/CDI/JSR330）、函数式定制拷贝。</p>
            
            <h3>Q: v1.1 有哪些新增/改进？</h3>
            <p><strong>A</strong>: 主要新增集合与数组字段的深拷贝，涵盖 List/Set/Map/数组及其嵌套组合，支持双向拷贝、null 元素安全处理、容量预分配，以及对原始类型/无界通配符集合的安全降级（回退浅拷贝并给出编译期告警）。</p>
            
            <h3>Q: Fast Bean Copier 是什么？</h3>
            <p><strong>A</strong>: Fast Bean Copier 是一个基于注解处理器的 Java Bean 拷贝工具，在编译期自动生成类型安全、高性能的 Bean 映射代码。</p>
            
            <h3>Q: 与 MapStruct 有什么区别？</h3>
            <p><strong>A</strong>: </p>
            <ul>
                <li>Fast Bean Copier 更简洁，只需一个 <code>@CopyTarget</code> 注解</li>
                <li>Fast Bean Copier 自动生成 List/Set 映射方法</li>
                <li>Fast Bean Copier 自动处理基本类型与包装类型转换</li>
                <li>MapStruct 功能更强大，支持更多高级特性</li>
            </ul>
            
            <h3>Q: 支持哪些 Java 版本？</h3>
            <p><strong>A</strong>: Java 8 及以上版本。</p>
            
            <h3>Q: 可以在 Gradle 项目中使用吗？</h3>
            <p><strong>A</strong>: 可以。在 <code>build.gradle</code> 中添加：</p>
            <pre><code>dependencies {
    implementation 'com.github.jackieonway:fast-bean-copier-annotations:1.2.1'
    annotationProcessor 'com.github.jackieonway:fast-bean-copier-processor:1.2.1'
}</code></pre>
            
            <h2>功能问题</h2>
            
            <h3>Q: 支持嵌套对象拷贝吗？</h3>
            <p><strong>A</strong>: 支持。同名字段会直接拷贝；当嵌套类型也使用 <code>@CopyTarget</code> 标注时，会自动递归深拷贝，无需手动补齐：</p>
            <pre><code>@CopyTarget(source = User.class)
public class UserDto {
    private AddressDto address; // 与源类 Address 对应
}</code></pre>
            
            <h3>Q: 集合/数组字段会自动深拷贝吗？</h3>
            <p><strong>A</strong>: 会。List/Set/Map/数组（含嵌套组合与多维数组）都会按元素深拷贝，基本类型/String 直接赋值，带 <code>@CopyTarget</code> 的对象调用对应 Copier，其余按类型匹配递归处理。null 集合/元素会被安全保留，容量预分配避免多次扩容。</p>
            
            <h3>Q: 原始类型或无界通配符的集合如何处理？</h3>
            <p><strong>A</strong>: 遇到 <code>List</code>、<code>Set</code>、<code>Map</code> 的 raw type 或 <code>?</code>/<code>? super</code> 等无法安全解析的通配符时，会回退为浅拷贝并输出编译期警告，建议为集合添加明确泛型。</p>
            
            <h3>Q: 支持自定义转换器吗？</h3>
            <p><strong>A</strong>: 支持（v1.2.0+）。可以通过以下方式使用自定义转换器：</p>
            <ul>
                <li>使用内置 TypeConverter：<code>@CopyField(converter = NumberFormatter.class, format = "#,##0.00")</code></li>
                <li>使用自定义转换器类：<code>@CopyTarget(source = User.class, uses = {CustomConverter.class})</code></li>
                <li>使用具名方法：<code>@CopyField(qualifiedByName = "methodName")</code></li>
            </ul>
            
            <h3>Q: 支持 Enum 转换吗？</h3>
            <p><strong>A</strong>: 支持（v1.2.0+）。使用内置的 <code>EnumStringConverter</code>：</p>
            <pre><code>@CopyField(converter = EnumStringConverter.class)
private String statusText;  // Status.ACTIVE -> "ACTIVE"</code></pre>
            
            <h3>Q: 如何使用依赖注入？</h3>
            <p><strong>A</strong>: 使用 <code>componentModel</code> 属性指定依赖注入框架（v1.2.0+）：</p>
            <pre><code>// Spring
@CopyTarget(source = User.class, componentModel = ComponentModel.SPRING)
public class UserDto { }

// CDI
@CopyTarget(source = User.class, componentModel = ComponentModel.CDI)
public class UserDto { }

// JSR-330
@CopyTarget(source = User.class, componentModel = ComponentModel.JSR330)
public class UserDto { }</code></pre>
            
            <h3>Q: 如何进行多字段映射？</h3>
            <p><strong>A</strong>: 使用 <code>@CopyField</code> 注解的 <code>source</code> 和 <code>expression</code> 属性（v1.2.0+）：</p>
            <pre><code>// 多对一：firstName + lastName -> fullName
@CopyField(source = {"firstName", "lastName"}, 
           expression = "source.getFirstName() + \" \" + source.getLastName()")
private String fullName;

// 一对多：fullName -> firstName
@CopyField(source = "fullName", 
           expression = "source.getFullName().split(\" \")[0]")
private String firstName;</code></pre>
            
            <h3>Q: 如何使用函数式定制？</h3>
            <p><strong>A</strong>: 使用带 <code>UnaryOperator</code> 参数的重载方法（v1.2.0+）：</p>
            <pre><code>UserDto dto = UserDtoCopier.toDto(user, result -> {
    result.setDisplayName(result.getName().toUpperCase());
    return result;
});

// 批量转换
List&lt;UserDto&gt; dtos = UserDtoCopier.toDtoList(users, result -> {
    result.setTimestamp(System.currentTimeMillis());
    return result;
});</code></pre>
            
            <h3>Q: 支持 Map 转换吗？</h3>
            <p><strong>A</strong>: 支持（v1.1.0+）。Key 通常直接拷贝（如 String/基本类型），Value 会按深拷贝规则处理；Map 为 null 时保持 null，Value 为 null 时保留；嵌套集合/数组的 Map 也会递归处理。</p>
            
            <h3>Q: 支持 Stream 转换吗？</h3>
            <p><strong>A</strong>: 当前版本不支持 Stream 的自动转换。可以使用 <code>toDtoList()</code> 或 <code>toDtoSet()</code> 后再转换为 Stream。</p>
            
            <h3>Q: Raw/无界通配符集合如何处理？</h3>
            <p><strong>A</strong>: 会降级为浅拷贝，并在编译期输出警告。建议为集合声明明确泛型参数以启用深拷贝。</p>
            
            <h3>Q: 支持 Builder 模式吗？</h3>
            <p><strong>A</strong>: 当前版本不支持。Copier 类使用 setter 方法进行赋值。</p>
            
            <h2>类型转换问题</h2>
            
            <h3>Q: 基本类型与包装类型如何转换？</h3>
            <p><strong>A</strong>: Fast Bean Copier 自动支持基本类型与包装类型的转换：</p>
            <pre><code>public class User {
    private int age;  // 基本类型
}

@CopyTarget(source = User.class)
public class UserDto {
    private Integer age;  // 包装类型，自动装箱
}

UserDto userDto = UserDtoCopier.toDto(user);
// userDto.age 为 Integer，值为 user.age</code></pre>
            
            <h3>Q: 包装类型转换为基本类型时，null 如何处理？</h3>
            <p><strong>A</strong>: null 会转换为基本类型的默认值：</p>
            <pre><code>UserDto userDto = new UserDto();
userDto.setAge(null);

User user = UserDtoCopier.fromDto(userDto);
// user.age 为 0（int 的默认值）</code></pre>
            
            <h3>Q: 支持 String 与其他类型的转换吗？</h3>
            <p><strong>A</strong>: 当前版本不支持。可以在应用层手动处理。</p>
            
            <h2>字段问题</h2>
            
            <h3>Q: 如何忽略某些字段？</h3>
            <p><strong>A</strong>: 使用 <code>@CopyTarget</code> 注解的 <code>ignore</code> 属性：</p>
            <pre><code>@CopyTarget(source = User.class, ignore = {"password", "token"})
public class UserDto {
    // password 和 token 不会被拷贝
}</code></pre>
            
            <h3>Q: 如何处理源类和目标类中字段名不同的情况？</h3>
            <p><strong>A</strong>: 当前版本不支持字段名映射。可以在应用层手动处理。</p>
            
            <h3>Q: 如何处理源类中有但目标类中没有的字段？</h3>
            <p><strong>A</strong>: 这些字段会被忽略，不会被拷贝。</p>
            
            <h3>Q: 如何处理目标类中有但源类中没有的字段？</h3>
            <p><strong>A</strong>: 这些字段不会被初始化，保持默认值。</p>
            
            <h2>集合问题</h2>
            
            <h3>Q: 支持哪些集合类型？</h3>
            <p><strong>A</strong>: 当前版本支持 List、Set 和 Map（v1.1.0+）。</p>
            
            <h3>Q: 支持 Map 吗？</h3>
            <p><strong>A</strong>: 支持（v1.1.0+）。Key 通常直接拷贝（如 String/基本类型），Value 会按深拷贝规则处理。</p>
            
            <h3>Q: 集合中的 null 元素如何处理？</h3>
            <p><strong>A</strong>: null 元素会被保留：</p>
            <pre><code>List&lt;User&gt; users = Arrays.asList(user1, null, user2);
List&lt;UserDto&gt; dtos = UserDtoCopier.toDtoList(users);
// dtos 中第二个元素为 null</code></pre>
            
            <h3>Q: 集合为 null 时如何处理？</h3>
            <p><strong>A</strong>: 返回 null：</p>
            <pre><code>List&lt;UserDto&gt; dtos = UserDtoCopier.toDtoList(null);
// dtos 为 null</code></pre>
            
            <h2>性能问题</h2>
            
            <h3>Q: Fast Bean Copier 的性能如何？</h3>
            <p><strong>A</strong>: Fast Bean Copier 在编译期生成代码，运行时性能与手写代码相同。没有反射开销，直接调用 getter/setter。</p>
            
            <h3>Q: 生成的代码可以被 JIT 编译器优化吗？</h3>
            <p><strong>A</strong>: 可以。生成的代码是普通 Java 代码，JIT 编译器可以进行内联等优化。</p>
            
            <h3>Q: 生成的 Copier 类是否线程安全？</h3>
            <p><strong>A</strong>: 是的。生成的 Copier 类是无状态的，可以安全地在多线程环境中使用。</p>
            
            <h2>开发问题</h2>
            
            <h3>Q: 生成的代码在哪里？</h3>
            <p><strong>A</strong>: 在 <code>target/generated-sources/annotations/</code> 目录下。</p>
            
            <h3>Q: 如何在 IDE 中查看生成的代码？</h3>
            <p><strong>A</strong>: 大多数 IDE（如 IntelliJ IDEA、Eclipse）都会自动识别生成的源代码。如果看不到，可以：</p>
            <ol>
                <li>刷新项目（F5 或右键 -> Refresh）</li>
                <li>重新构建项目（Clean -> Build）</li>
            </ol>
            
            <h3>Q: 可以修改生成的代码吗？</h3>
            <p><strong>A</strong>: 不推荐。生成的代码会在每次编译时被覆盖。如果需要自定义，应该在应用层处理。</p>
            
            <h3>Q: 如何调试生成的代码？</h3>
            <p><strong>A</strong>: 可以在 IDE 中设置断点，调试器会进入生成的代码。</p>
            
            <h3>Q: 支持 Lombok 吗？</h3>
            <p><strong>A</strong>: 支持。Fast Bean Copier 可以与 Lombok 一起使用，Lombok 会生成 getter/setter 方法。</p>
            <pre><code>@Data
public class User {
    private Long id;
    private String name;
}

@Data
@CopyTarget(source = User.class)
public class UserDto {
    private Long id;
    private String name;
}</code></pre>
            
            <h3>Q: 支持 Gradle 的增量编译吗？</h3>
            <p><strong>A</strong>: 支持。Fast Bean Copier 与 Gradle 的增量编译兼容。</p>
            
            <h2>故障排除</h2>
            
            <h3>Q: 编译时出现 "找不到符号" 错误</h3>
            <p><strong>A</strong>: </p>
            <ol>
                <li>检查 <code>@CopyTarget</code> 注解是否正确使用</li>
                <li>检查源类是否存在</li>
                <li>运行 <code>mvn clean compile</code> 进行完整编译</li>
            </ol>
            
            <h3>Q: 生成的 Copier 类未出现</h3>
            <p><strong>A</strong>: </p>
            <ol>
                <li>确保使用了 <code>@CopyTarget</code> 注解</li>
                <li>确保源类和目标类都有 getter/setter 方法</li>
                <li>运行 <code>mvn clean compile</code> 进行完整编译</li>
                <li>检查编译日志中是否有错误</li>
            </ol>
            
            <h3>Q: 字段未被拷贝</h3>
            <p><strong>A</strong>: </p>
            <ol>
                <li>检查字段名是否完全相同（区分大小写）</li>
                <li>检查源类和目标类是否都有该字段的 getter/setter</li>
                <li>检查该字段是否在 <code>ignore</code> 属性中</li>
            </ol>
            
            <h3>Q: IDE 中看不到生成的代码</h3>
            <p><strong>A</strong>: </p>
            <ol>
                <li>刷新项目（F5 或右键 -> Refresh）</li>
                <li>重新构建项目（Clean -> Build）</li>
                <li>检查 IDE 是否启用了注解处理（通常默认启用）</li>
            </ol>
            
            <h3>Q: 编译时出现 "不兼容的类型" 错误</h3>
            <p><strong>A</strong>: </p>
            <ol>
                <li>检查源类和目标类的字段类型是否兼容</li>
                <li>对于不兼容的类型，在应用层手动处理</li>
            </ol>
            
            <h2>最佳实践</h2>
            
            <h3>Q: 如何组织代码？</h3>
            <p><strong>A</strong>: 推荐的结构：</p>
            <pre><code>src/
├── main/
│   ├── java/
│   │   ├── entity/      # 实体类
│   │   ├── dto/         # DTO 类
│   │   ├── service/     # 业务逻辑
│   │   └── controller/  # 控制器
│   └── resources/
└── test/</code></pre>
            
            <h3>Q: 何时使用 Fast Bean Copier？</h3>
            <p><strong>A</strong>: 适用于：</p>
            <ul>
                <li>API 响应 DTO 转换</li>
                <li>数据库实体与 DTO 转换</li>
                <li>微服务间的数据转换</li>
                <li>批量数据转换</li>
            </ul>
            
            <h3>Q: 何时不使用 Fast Bean Copier？</h3>
            <p><strong>A</strong>: 不适用于：</p>
            <ul>
                <li>需要复杂的字段映射逻辑</li>
                <li>需要条件转换</li>
                <li>需要自定义转换器</li>
            </ul>
            
            <h2>获取帮助</h2>
            
            <h3>Q: 如何报告 Bug？</h3>
            <p><strong>A</strong>: 在 <a href="https://github.com/fast-bean-copier/fast-bean-copier/issues" target="_blank">GitHub Issues</a> 中提出问题，包括：</p>
            <ol>
                <li>问题描述</li>
                <li>复现步骤</li>
                <li>期望行为</li>
                <li>实际行为</li>
                <li>环境信息（Java 版本、Maven 版本等）</li>
            </ol>
            
            <h3>Q: 如何提出功能请求？</h3>
            <p><strong>A</strong>: 在 <a href="https://github.com/fast-bean-copier/fast-bean-copier/issues" target="_blank">GitHub Issues</a> 中提出，描述：</p>
            <ol>
                <li>功能描述</li>
                <li>使用场景</li>
                <li>期望的 API</li>
            </ol>
            
            <h3>Q: 如何贡献代码？</h3>
            <p><strong>A</strong>: 欢迎提交 Pull Request！请确保：</p>
            <ol>
                <li>代码遵循项目的代码风格</li>
                <li>添加相应的单元测试</li>
                <li>更新文档</li>
                <li>提交信息清晰明了</li>
            </ol>
        </div>
    </div>
    
    <footer>
        <p>&copy; 2026 Fast Bean Copier. All rights reserved.</p>
        <p>采用 Apache License 2.0 许可证</p>
    </footer>
    
    <script src="../script.js"></script>
</body>
</html>

