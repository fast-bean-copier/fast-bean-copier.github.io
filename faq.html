<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>常见问题 - Fast Bean Copier</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="container">
            <div class="logo-container">
                <img src="logo.png" alt="Fast Bean Copier Logo" class="logo">
                <h1>🚀 Fast Bean Copier</h1>
            </div>
            <p>高性能的 Java Bean 拷贝工具</p>
            <div class="version-badge">版本 1.0.0</div>
        </div>
    </header>
    
    <nav>
        <ul>
            <li><a href="index.html">首页</a></li>
            <li><a href="getting-started.html">快速入门</a></li>
            <li><a href="reference.html">参考文档</a></li>
            <li><a href="api.html">API 文档</a></li>
            <li><a href="faq.html" class="active">常见问题</a></li>
            <li><a href="summary.html">项目总结</a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="content">
            <h1>Fast Bean Copier 常见问题解答</h1>
            
            <h2>基本问题</h2>
            
            <h3>Q: Fast Bean Copier 是什么？</h3>
            <p><strong>A:</strong> Fast Bean Copier 是一个基于注解处理器的 Java Bean 拷贝工具，在编译期自动生成类型安全、高性能的 Bean 映射代码。</p>
            
            <h3>Q: 与 MapStruct 有什么区别？</h3>
            <p><strong>A:</strong></p>
            <ul>
                <li>Fast Bean Copier 更简洁，只需一个 <code>@CopyTarget</code> 注解</li>
                <li>Fast Bean Copier 自动生成 List/Set 映射方法</li>
                <li>Fast Bean Copier 自动处理基本类型与包装类型转换</li>
                <li>MapStruct 功能更强大，支持更多高级特性</li>
            </ul>
            
            <h3>Q: 支持哪些 Java 版本？</h3>
            <p><strong>A:</strong> Java 8 及以上版本。</p>
            
            <h3>Q: 可以在 Gradle 项目中使用吗？</h3>
            <p><strong>A:</strong> 可以。在 <code>build.gradle</code> 中添加：</p>
            <pre><code>dependencies {
    implementation 'com.github.jackieonway:fast-bean-copier-annotations:1.0.0'
    annotationProcessor 'com.github.jackieonway:fast-bean-copier-processor:1.0.0'
}</code></pre>
            
            <h2>功能问题</h2>
            
            <h3>Q: 支持嵌套对象拷贝吗？</h3>
            <p><strong>A:</strong> 支持。同名字段会直接拷贝。对于不同类型的嵌套对象，可以为嵌套对象也定义 <code>@CopyTarget</code>。</p>
            
            <h3>Q: 支持自定义转换器吗？</h3>
            <p><strong>A:</strong> 当前版本不支持。可以在应用层手动处理特殊字段的转换。</p>
            
            <h3>Q: 支持 Enum 转换吗？</h3>
            <p><strong>A:</strong> 当前版本不支持 Enum 的自动转换。可以在应用层手动处理。</p>
            
            <h3>Q: 支持 Map 转换吗？</h3>
            <p><strong>A:</strong> 当前版本不支持 Map 的自动转换。</p>
            
            <h3>Q: 支持 Builder 模式吗？</h3>
            <p><strong>A:</strong> 当前版本不支持。Copier 类使用 setter 方法进行赋值。</p>
            
            <h2>类型转换问题</h2>
            
            <h3>Q: 基本类型与包装类型如何转换？</h3>
            <p><strong>A:</strong> Fast Bean Copier 自动支持基本类型与包装类型的转换：</p>
            <pre><code>public class User {
    private int age;  // 基本类型
}

@CopyTarget(source = User.class)
public class UserDto {
    private Integer age;  // 包装类型，自动装箱
}

UserDto userDto = UserDtoCopier.toDto(user);
// userDto.age 为 Integer，值为 user.age</code></pre>
            
            <h3>Q: 包装类型转换为基本类型时，null 如何处理？</h3>
            <p><strong>A:</strong> null 会转换为基本类型的默认值：</p>
            <pre><code>UserDto userDto = new UserDto();
userDto.setAge(null);

User user = UserDtoCopier.fromDto(userDto);
// user.age 为 0（int 的默认值）</code></pre>
            
            <h3>Q: 支持 String 与其他类型的转换吗？</h3>
            <p><strong>A:</strong> 当前版本不支持。可以在应用层手动处理。</p>
            
            <h2>字段问题</h2>
            
            <h3>Q: 如何忽略某些字段？</h3>
            <p><strong>A:</strong> 使用 <code>@CopyTarget</code> 注解的 <code>ignore</code> 属性：</p>
            <pre><code>@CopyTarget(source = User.class, ignore = {"password", "token"})
public class UserDto {
    // password 和 token 不会被拷贝
}</code></pre>
            
            <h3>Q: 如何处理源类和目标类中字段名不同的情况？</h3>
            <p><strong>A:</strong> 当前版本不支持字段名映射。可以在应用层手动处理。</p>
            
            <h3>Q: 如何处理源类中有但目标类中没有的字段？</h3>
            <p><strong>A:</strong> 这些字段会被忽略，不会被拷贝。</p>
            
            <h3>Q: 如何处理目标类中有但源类中没有的字段？</h3>
            <p><strong>A:</strong> 这些字段不会被初始化，保持默认值。</p>
            
            <h2>集合问题</h2>
            
            <h3>Q: 支持哪些集合类型？</h3>
            <p><strong>A:</strong> 当前版本支持 List 和 Set。</p>
            
            <h3>Q: 集合中的 null 元素如何处理？</h3>
            <p><strong>A:</strong> null 元素会被保留：</p>
            <pre><code>List&lt;User&gt; users = Arrays.asList(user1, null, user2);
List&lt;UserDto&gt; dtos = UserDtoCopier.toDtoList(users);
// dtos 中第二个元素为 null</code></pre>
            
            <h3>Q: 集合为 null 时如何处理？</h3>
            <p><strong>A:</strong> 返回 null：</p>
            <pre><code>List&lt;UserDto&gt; dtos = UserDtoCopier.toDtoList(null);
// dtos 为 null</code></pre>
            
            <h2>性能问题</h2>
            
            <h3>Q: Fast Bean Copier 的性能如何？</h3>
            <p><strong>A:</strong> Fast Bean Copier 在编译期生成代码，运行时性能与手写代码相同。没有反射开销，直接调用 getter/setter。</p>
            
            <h3>Q: 生成的代码可以被 JIT 编译器优化吗？</h3>
            <p><strong>A:</strong> 可以。生成的代码是普通 Java 代码，JIT 编译器可以进行内联等优化。</p>
            
            <h3>Q: 生成的 Copier 类是否线程安全？</h3>
            <p><strong>A:</strong> 是的。生成的 Copier 类是无状态的，可以安全地在多线程环境中使用。</p>
            
            <h2>开发问题</h2>
            
            <h3>Q: 生成的代码在哪里？</h3>
            <p><strong>A:</strong> 在 <code>target/generated-sources/annotations/</code> 目录下。</p>
            
            <h3>Q: 如何在 IDE 中查看生成的代码？</h3>
            <p><strong>A:</strong> 大多数 IDE（如 IntelliJ IDEA、Eclipse）都会自动识别生成的源代码。如果看不到，可以：</p>
            <ol>
                <li>刷新项目（F5 或右键 -> Refresh）</li>
                <li>重新构建项目（Clean -> Build）</li>
            </ol>
            
            <h3>Q: 可以修改生成的代码吗？</h3>
            <p><strong>A:</strong> 不推荐。生成的代码会在每次编译时被覆盖。如果需要自定义，应该在应用层处理。</p>
            
            <h3>Q: 支持 Lombok 吗？</h3>
            <p><strong>A:</strong> 支持。Fast Bean Copier 可以与 Lombok 一起使用，Lombok 会生成 getter/setter 方法。</p>
            
            <h2>故障排除</h2>
            
            <h3>Q: 编译时出现 "找不到符号" 错误</h3>
            <p><strong>A:</strong></p>
            <ol>
                <li>检查 <code>@CopyTarget</code> 注解是否正确使用</li>
                <li>检查源类是否存在</li>
                <li>运行 <code>mvn clean compile</code> 进行完整编译</li>
            </ol>
            
            <h3>Q: 生成的 Copier 类未出现</h3>
            <p><strong>A:</strong></p>
            <ol>
                <li>确保使用了 <code>@CopyTarget</code> 注解</li>
                <li>确保源类和目标类都有 getter/setter 方法</li>
                <li>运行 <code>mvn clean compile</code> 进行完整编译</li>
                <li>检查编译日志中是否有错误</li>
            </ol>
            
            <h3>Q: 字段未被拷贝</h3>
            <p><strong>A:</strong></p>
            <ol>
                <li>检查字段名是否完全相同（区分大小写）</li>
                <li>检查源类和目标类是否都有该字段的 getter/setter</li>
                <li>检查该字段是否在 <code>ignore</code> 属性中</li>
            </ol>
            
            <h3>Q: IDE 中看不到生成的代码</h3>
            <p><strong>A:</strong></p>
            <ol>
                <li>刷新项目（F5 或右键 -> Refresh）</li>
                <li>重新构建项目（Clean -> Build）</li>
                <li>检查 IDE 是否启用了注解处理（通常默认启用）</li>
            </ol>
        </div>
    </div>
    
    <footer>
        <p>&copy; 2025 Fast Bean Copier. All rights reserved.</p>
        <p>采用 Apache License 2.0 许可证</p>
    </footer>
</body>
</html>
